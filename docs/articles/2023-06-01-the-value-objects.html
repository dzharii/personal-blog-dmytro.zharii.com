<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>The Value Objects </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="The Value Objects ">
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../styles/docfx.min.css">
      <link rel="stylesheet" href="../styles/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      <meta name="docfx:docurl" content="https://github.com/dzharii/personal-blog-dmytro.zharii.com/blob/main/articles/2023-06-01-the-value-objects.md/#L1">

      <script>
        MathJax = {
          options: {
            processHtmlClass: ['tex2jax_process', 'math']
          }
        };
      </script>

      <script type="text/javascript" src="../styles/docfx.min.js"></script>
      <script type="text/javascript" src="../styles/main.js"></script>
  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navbar">
            <form class="d-flex ms-auto" role="search" id="search">
              <i class="bi bi-search"></i>
              <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
            </form>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="the-value-objects">The Value Objects</h1>

<p>Date: 2023-06-01</p>
<p>I will allow myself to think outside the box. (from the aww tools)</p>
<div class="NOTE">
<h5>Note</h5>
<p>This is a never-ending article, always in beta version.</p>
</div>
<p>In this article, we explore the concept of Value Objects. We start by understanding their role in ensuring data integrity, using a simple example of representing distances. We then delve into key features of Value Objects like constructor validation and immutability.</p>
<p>We enhance our example by introducing common operations into our Value Object, demonstrating cleaner and more intuitive code. We also illustrate the use of Value Objects for input parameters in the context of a legacy system bug fix, showcasing their power in code expressiveness and safety.</p>
<p>Finally, we emphasize the importance of unit testing in verifying the behavior of our Value Objects. By the end, you will have a comprehensive understanding of how to implement Value Objects effectively in your codebase.</p>
<h2 id="the-value-of-value-objects">The Value of Value Objects</h2>
<p>Value Objects. Value Objects come in all sorts of shapes and sizes. Let's dive into an example that seems simple at first.</p>
<p>This is an example from the normal life, for starters.</p>
<pre><code class="lang-csharp">void PrintDistance(int meters) {
  WriteLine($&quot;The distance is {meters} m.&quot;);
}
</code></pre>
<p>This code looks just fine until we start to ponder some hard questions. Can we fully trust the <code>int meters</code>? How can we <strong>ensure</strong> that the variable <code>meters</code> holds a <strong>valid</strong> value? What if someone mistakenly feeds the distance in <strong>feet</strong> into our function? So, <strong>who</strong> is on guard to <strong>validate</strong> <code>int meters</code>?</p>
<p>Suddenly, our straightforward example might become a tricky puzzle when we think about validation. No one-size-fits-all solution exists to this issue because the correct answer might change based on different circumstances.</p>
<p>However, we could consider a different approach. Let's modify our previous code to something like this:</p>
<pre><code class="lang-cs">void PrintDistance(Meters distance) {
  WriteLine($&quot;The distance is {distance.Value} m.&quot;);
}
</code></pre>
<p>We've swapped <code>int meters</code> with <code>Meters distance</code>. Here, <code>Meters</code> <strong>becomes a Value Object</strong>.</p>
<p>Think of it as a reliable friend that promises to always hold a valid value once it's created. This way, we're passing the responsibility of providing correct data to the Caller. Now, it's up to the Caller to provide a valid &quot;Meters distance&quot;. It's a subtle but effective way to keep the integrity of our PrintDistance function. How's that for a twist?</p>
<h2 id="inside-the-value-objects">Inside the Value Objects</h2>
<p><em>&quot;Only Sith and Value Objects deal in absolutes, Anakin!&quot; - Obi-Wan KeBoolean</em></p>
<h3 id="constructor-validation">Constructor Validation</h3>
<p>One of the <strong>key features</strong> of <strong>value objects</strong> is their commitment to <strong>always</strong> contain a <strong>valid</strong> value — well, at least as valid as our programming allows it to be. A simple and effective way to ensure this is by incorporating validation into the <strong>constructor</strong>.</p>
<p>So, it's a pretty straightforward situation: either we <strong>create a valid value</strong> object <strong>or</strong> run into an <strong>error</strong>. No third option here!</p>
<p>Let's reconsider our Meters example. While there isn't a one-size-fits-all approach to thoroughly validate Meters, we can tailor our validation to fit the project's specific needs. We'll lay down some ground rules based on the business requirements. So, for the purposes of this article, here's what we'll go with:</p>
<div class="NOTE">
<h5>Note</h5>
<ol>
<li>Meters are represented <strong>as integer</strong> values because we're not sweating the small stuff — centimeters don't concern us here.</li>
<li>Meters must be <strong>positive integers</strong>. Why? Because in our world, we don't do negative distances.</li>
<li>The value for Meters <strong>can't exceed 999</strong>. It's a bit of an old-school restriction, but it's still hanging around.</li>
</ol>
</div>
<p>Let's see an example of how Meters might be implemented in C#.</p>
<pre><code class="lang-csharp">namespace HelloWorld;

// The Value Object
public class Meters
{
    public int Value { get; }

    // Constructor for the Meters class.
    // It includes validation to ensure we're abiding by our defined rules.
    public Meters(int value)
    {
        // Rule 1: Meters must be positive integers.
        if (value &lt;= 0)
        {
            throw new ArgumentException($&quot;Invalid value for Meters: {value}. Meters must be a positive integer.&quot;);
        }

        // Rule 2: Meters can't exceed 999.
        if (value &gt; 999)
        {
            throw new ArgumentException($&quot;Invalid value for Meters: {value}. Meters cannot be greater than 999.&quot;);
        }

        Value = value;
    }
}

</code></pre><h3 id="immutability">Immutability</h3>
<p>Another very <strong>essential property</strong> for value objects is <strong>immutability</strong>. This means that once value objects are created, they are set in stone – the value they encapsulate doesn't change. It's read-only or &quot;immutable&quot;. The specifics of how you implement this characteristic can differ based on your chosen programming language.</p>
<p>For example, in C#, integers are inherently immutable. There's no need to add extra code to duplicate the value. However, for more complex scenarios, adding some code to return a clone of the value stored within the value object is necessary.</p>
<p>Let's illustrate this using our Meters class. We'll demonstrate how to sum two instances of Meters:</p>
<pre><code class="lang-csharp">// Assuming you have two instances of Meters
Meters first = new Meters(200);
Meters second = new Meters(300);

// You can add the values together to create a new Meters instance
Meters third = new Meters(first.Value + second.Value);

Console.WriteLine($&quot;The total distance is {third.Value} m.&quot;);
</code></pre>
<p>Value objects, like in our Meters example, can be customized to fit the specific needs of your application and coding style. We've noticed a frequent operation - adding Meters together. It makes sense to embed this operation into the Meters class by introducing an <code>Add()</code> method. This adjustment not only leads to cleaner code but also enhances its intuitiveness.</p>
<pre><code class="lang-csharp">public class Meters
{
    public int Value { get; private set; }

    public Meters(int value)
    {
        if (value &lt;= 0)
        {
            throw new ArgumentException($&quot;Invalid value for Meters: {value}. Meters must be a positive integer.&quot;);
        }

        if (value &gt; 999)
        {
            throw new ArgumentException($&quot;Invalid value for Meters: {value}. Meters cannot be greater than 999.&quot;);
        }

        Value = value;
    }

    // Adding an 'add' method
    public Meters Add(Meters other)
    {
        return new Meters(this.Value + other.Value);
    }
}

// Now, let's illustrate how this new method works:

Meters first = new Meters(200);
Meters second = new Meters(300);

// Using the new 'add' method to create a new Meters instance
Meters total = first.Add(second);

Console.WriteLine($&quot;The total distance is {total.Value} m.&quot;);
</code></pre>
<p>Please note: once created, the <strong>value objects must remain valid</strong>. This is the core property. And the most straightforward way to keep the value objects valid is to make them immutable.</p>
<h2 id="value-objects-for-input-parameters">Value Objects for Input Parameters</h2>
<p>Hey there, dear Reader! Kudos for sticking around through this deep dive. You may think, &quot;This is all great, but what about the slower code when adding Meters?&quot; Hang tight – we'll address performance concerns a bit later. Let's shift our focus to a scenario where performance isn't an issue and Value Objects truly shine: when they're used to encapsulate program input parameters.</p>
<p>Imagine this – we've got an old-school legacy system using Postgres SQL for data storage. Occasionally, a sneaky bug creates chaos – messing up data links or dropping in duplicate records. We're on a mission to find the root cause, but in the meantime, we need to keep our database in order.</p>
<p>What's our strategy? We decide to roll out a maintenance script – a triage workflow to patch up the data wounds. It's not a cure-all; we can't heal the buggy code. It's a bit like changing a tire on a moving car – risky, sure, but necessary. The System needs to stay online and handle user requests.</p>
<pre><code class="lang-csharp">namespace HelloWorld;
using System;

/*
 * This program simulates the workflow of updating a customer record in a database. 
 * The main function of the Program class accepts three command line arguments: customerId, 
 * ordersPlaced, and lastModified. 
 * - customerId: Should be a valid, non-empty Guid that is not reserved for the application admin.
 * - ordersPlaced: Should be an integer greater or equal to 0 but less than 99.
 * - lastModified: Should be a DateTime value between the store's establishment date (January 1, 2018) 
 *   and December 31, 2099.
 * If all parameters pass these validations, the program then calls the ExecuteWorkflow method, 
 * simulating an update to the database.
 */
public class Program
{
    private static readonly DateTime StoreEstablishedDate = new DateTime(2018, 1, 1);
    private static readonly DateTime FutureCutoffDate = new DateTime(2099, 12, 31);

    public static void Main(string[] args)
    {
        if (args.Length != 3)
        {
            Console.WriteLine(&quot;Please enter the correct parameters: customerId, ordersPlaced, lastModified.&quot;);
            return;
        }

        // Parameter: CustomerId
        Guid customerId;
        if (!Guid.TryParse(args[0], out customerId))
        {
            Console.WriteLine(&quot;The customerId should be a valid Guid value.&quot;);
            return;
        }

        // Empty Guid Check
        if (customerId == Guid.Empty)
        {
            Console.WriteLine(&quot;The customerId cannot be an empty Guid.&quot;);
            return;
        }

        // Application Admin Guid Check
        if (customerId == Guid.Parse(&quot;ea2a9d01-e719-42f2-9e5d-56287f142c48&quot;))
        {
            Console.WriteLine(&quot;The entered customerId is reserved for the application admin.&quot;);
            return;
        }

        // Parameter: ordersPlaced
        int ordersPlaced;
        if (!int.TryParse(args[1], out ordersPlaced) || ordersPlaced &lt; 0 || ordersPlaced &gt;= 99)
        {
            Console.WriteLine(&quot;The ordersPlaced should be a number greater than or equal to 0 but less than 99.&quot;);
            return;
        }

        // Parameter: lastModified
        DateTime lastModified;
        if (!DateTime.TryParse(args[2], out lastModified) 
            || lastModified &lt; StoreEstablishedDate 
            || lastModified &gt; FutureCutoffDate)
        {
            Console.WriteLine(&quot;The lastModified should be a date between the store's established date &quot;
                              + &quot;and December 31, 2099.&quot;);
            return;
        }

        // All validations passed, we can call the method
        ExecuteWorkflow(customerId, ordersPlaced, lastModified);
    }

    public static void ExecuteWorkflow(Guid customerId, int ordersPlaced, DateTime lastModified)
    {
        //Database.UpdateRecord(customerId, ordersPlaced, lastModified);
        Console.WriteLine($&quot;Updating Record: CustomerId: {customerId}, OrdersPlaced: {ordersPlaced}, &quot;
                          + $&quot;LastModified: {lastModified}&quot;);
    }
}
</code></pre>
<p>Our program is running smoothly! We've effectively validated parameters based on our business rules. There's room for unit tests, but let's keep this article simple.
Let's say our approach is so practical that we're tasked with creating more workflows. Before we know it, we've got a whole set of them, each validating things like customer IDs, order dates, and last modified dates. We could streamline our code by putting our validation logic into a method like 'ValidateCustomerId', but what if someone forgets to use it down the line?
This brings us to an exciting solution: how about making it impossible to create an incorrect CustomerId instance? This is exactly where Value Objects come into play!</p>
<p>The main class:</p>
<pre><code class="lang-csharp">public class Program
{
    public static void Main(string[] args)
    {
        if (args.Length != 3)
        {
            Console.WriteLine(&quot;Please enter the correct parameters: customerId, ordersPlaced, lastModified.&quot;);
            return;
        }
                
        try
        {
            CustomerId customerId = CustomerId.Parse(args[0]);
            OrdersPlaced ordersPlaced = OrdersPlaced.Parse(args[1]);
            OrderLastModified lastModified = OrderLastModified.Parse(args[2]);

            ExecuteWorkflow(customerId, ordersPlaced, lastModified);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
    }

    public static void ExecuteWorkflow(CustomerId customerId, OrdersPlaced ordersPlaced, OrderLastModified lastModified)
    {
        Database.UpdateRecord(customerId.Value, ordersPlaced.Value, lastModified.Value);
    }
}
</code></pre>
<p>You might notice how much clearer our code has become.</p>
<pre><code class="lang-csharp">CustomerId customerId = CustomerId.Parse(args[0]);
</code></pre>
<p>When you call <code>CustomerId.Parse</code>, it pulls the GUID from a string and creates a Value Object. This step also makes sure that the CustomerId is correct. Yes, it takes a few more lines of code to create these Value Objects, but don't worry. We'll keep these classes neatly tucked away in their own separate files. In future workflows, we can use these Value Objects without looking into their source code. After all, how often do we peek under the hood of <code>System.String</code> or <code>System.Guid</code>? Not very, right?</p>
<p>Value objects:</p>
<pre><code class="lang-csharp">namespace HelloWorld;

// CustomerId: A value object that represents the unique identifier of a customer.
public class CustomerId
{
    public Guid Value { get; }

    public static readonly Guid AdminId = Guid.Parse(&quot;ea2a9d01-e719-42f2-9e5d-56287f142c48&quot;);

    public CustomerId(Guid customerId)
    {
        if (customerId == Guid.Empty || customerId == AdminId)
        {
            throw new ArgumentException(&quot;Customer Id can't be empty or admin Id.&quot;);
        }

        Value = customerId;
    }

    public static CustomerId Parse(string input)
    {
        if (!Guid.TryParse(input, out Guid output))
        {
            throw new ArgumentException(&quot;Customer Id must be a valid GUID.&quot;);
        }

        return new CustomerId(output);
    }
}

// OrdersPlaced: A value object that encapsulates the number of orders a customer has placed.
public class OrdersPlaced
{
    public int Value { get; }

    public OrdersPlaced(int ordersPlaced)
    {
        if (ordersPlaced &lt; 0 || ordersPlaced &gt; 98)
        {
            throw new ArgumentException(&quot;Orders placed must be between 0 and 98.&quot;);
        }

        Value = ordersPlaced;
    }

    public static OrdersPlaced Parse(string input)
    {
        if (!int.TryParse(input, out int output))
        {
            throw new ArgumentException(&quot;Orders placed must be a valid integer.&quot;);
        }

        return new OrdersPlaced(output);
    }
}

// OrderLastModified: A value object that represents the last date an order was modified.
public class OrderLastModified
{
    public DateTime Value { get; }

    private static readonly DateTime MinDate = new DateTime(2018, 1, 1);
    private static readonly DateTime MaxDate = new DateTime(2099, 12, 31);

    public OrderLastModified(DateTime lastModified)
    {
        if (lastModified &lt; MinDate || lastModified &gt; MaxDate)
        {
            throw new ArgumentException($&quot;OrderLastModified date must be between {MinDate} and {MaxDate}.&quot;);
        }

        Value = lastModified;
    }

    public static OrderLastModified Parse(string input)
    {
        if (!DateTime.TryParse(input, out DateTime output))
        {
            throw new ArgumentException(&quot;OrderLastModified must be a valid date.&quot;);
        }

        return new OrderLastModified(output);
    }
}


public class Program
{
    public static void Main(string[] args)
    {
        if (args.Length != 3)
        {
            Console.WriteLine(&quot;Please enter the correct parameters: customerId, ordersPlaced, lastModified.&quot;);
            return;
        }
                
        try
        {
            CustomerId customerId = CustomerId.Parse(args[0]);
            OrdersPlaced ordersPlaced = OrdersPlaced.Parse(args[1]);
            OrderLastModified lastModified = OrderLastModified.Parse(args[2]);

            ExecuteWorkflow(customerId, ordersPlaced, lastModified);
        }
        catch (Exception e)
        {
            Console.WriteLine(e.Message);
        }
    }

    public static void ExecuteWorkflow(CustomerId customerId, OrdersPlaced ordersPlaced, OrderLastModified lastModified)
    {
        Database.UpdateRecord(customerId.Value, ordersPlaced.Value, lastModified.Value);
    }
}


</code></pre>
<p>Unit tests for <code>CustomerId</code>:</p>
<pre><code class="lang-csharp">using System;
using Xunit;

public class CustomerIdTests
{
    // Test: Create a `CustomerId` with a valid `Guid` and 
    // check if the `Value` property is set correctly
    [Fact]
    public void Constructor_WithValidGuid_ShouldSetTheValue()
    {
        Guid expectedValue = Guid.NewGuid();

        var customerId = new CustomerId(expectedValue);

        Assert.Equal(expectedValue, customerId.Value);
    }

    // Test: Try to create a `CustomerId` with an empty `Guid`, 
    // expecting an exception
    [Fact]
    public void Constructor_WithEmptyGuid_ShouldThrowException()
    {
        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new CustomerId(Guid.Empty));
    }

    // Test: Try to create a `CustomerId` 
    // with the `AdminId` `Guid`, expecting an exception
    [Fact]
    public void Constructor_WithAdminIdGuid_ShouldThrowException()
    {
        Guid adminId = CustomerId.AdminId;

        Assert.Throws&lt;ArgumentException&gt;(() =&gt; new CustomerId(adminId));
    }

    // Test: Parse a valid `Guid` string and 
    // return a `CustomerId` with the correct `Value`
    [Fact]
    public void Parse_WithValidGuidString_ShouldReturnCustomerId()
    {
        string validGuidString = Guid.NewGuid().ToString();

        var customerId = CustomerId.Parse(validGuidString);

        Assert.Equal(Guid.Parse(validGuidString), customerId.Value);
    }

    // Test: Try to parse an invalid `Guid` string, expecting an exception
    [Fact]
    public void Parse_WithInvalidGuidString_ShouldThrowException()
    {
        string invalidGuidString = &quot;invalid guid&quot;;

        Assert.Throws&lt;ArgumentException&gt;(() =&gt; CustomerId.Parse(invalidGuidString));
    }
}
</code></pre>
<p>Highlight: We need to write unit tests once and only once since we do not repeat the validation logic and keep it inside the <code>CustomerId</code>.</p>
<h2 id="the-advantages-of-value-objects">The Advantages of Value Objects</h2>
<ul>
<li>Eliminates redundancy. The object itself is the single source of truth.</li>
<li>Reduces testing efforts. By removing duplication, we need to write just one test per behavior. All validation checks are encapsulated within the object, so we don't need to worry about handling invalid data.</li>
<li>Leverages compiler checks in statically typed languages. You can't supply anything but a <code>CustomerId</code> when it's required, boosting code robustness. Even in dynamic languages, the error traces are more helpful than with primitive types.</li>
<li>Minimizes the chance of argument misconfiguration. Now <code>CustomerId</code> is a strongly typed object, not a generic string.</li>
<li>Streamlines code expectations. Using our <code>CustomerId</code> example, we can rely on class preconditions to ensure things like non-null, non-empty forenames and surnames of a certain length. A basic string can't provide such guarantees.</li>
<li>Encourages making value objects public, which can benefit testing and integration.</li>
</ul>
<h2 id="once-more-anakin">Once More, Anakin!</h2>
<p>Value objects are tailor-made for Sith. As Sith, we <strong>don't assume - we assert!</strong>
When we establish our communication interface using value objects:</p>
<pre><code class="lang-csharp">public static void ExecuteWorkflow(CustomerId customerId, OrdersPlaced ordersPlaced, OrderLastModified lastModified)
{
    Database.UpdateRecord(customerId.Value, ordersPlaced.Value, lastModified.Value);
}
</code></pre>
<p>We affirm that the <strong>caller's responsible</strong> for supplying us with valid values. Correcting erroneous data lies with the <strong>caller</strong> - they must handle this before creating the value object. This approach forms a <strong>clear boundary</strong>, thus enhancing communication across different program components.</p>
<h2 id="value-objects-in-c-language">Value Objects in C language</h2>
<p><em>Added: 2023-06-22</em></p>
<p>Let's talk about C. For those who code in this language, there's a good reason for doing so. I, for one, wouldn't claim to be a C maestro, so remember to take my words with a grain of salt.</p>
<p>Here's the deal with C: it gives you all the power to code at a low system level, but it doesn't come without a catch. It demands meticulous attention and discipline. In C, the blame game ends on your keyboard. Every mistake is your own doing. It's not about the language or the compiler; it's all about you. So, beware.</p>
<p>Now, don't let this scare you off. It should encourage you. Who doesn't enjoy a good puzzle? And I still find myself tripping over some double-pointer arithmetic occasionally.</p>
<p>In C, notions like &quot;read-only&quot; or &quot;private&quot; data don't quite fit in. Immutability? More of a mental construct than a language feature. It's C, after all.</p>
<p>That being said, there's a trick we can use to make things more organized: value objects. These self-validating objects can be pretty handy. Not only do they ensure our data is in the right state, but they also help keep our code clean and easy to understand.</p>
<p>If you haven't already, give value objects a try. They might be the secret ingredient you didn't know you were missing.</p>
<p><strong>main.c:</strong></p>
<pre><code class="lang-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &quot;meters.h&quot;
#include &quot;operation.h&quot;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

// A function to parse a double from a string with error checking.
double parse_double(const char* str) {
    char* endptr;
    errno = 0; // To distinguish success/failure after call

    // check that str is not longer than 10 characters
    if (strnlen(str, 20) == 20) {
        printf(&quot;Error: provided number is too long\n&quot;);
        exit(EXIT_FAILURE);
    }

    // check that str contains only digits and a single decimal point
    int i = 0;
    for (; str[i] != '\0'; i++) {
        char c = str[i];
        if (c == '.') {
            if (i == 0) {
                printf(&quot;Error: decimal point must be preceded by a digit\n&quot;);
                exit(EXIT_FAILURE);
            }
            if (str[i + 1] == '\0') {
                printf(&quot;Error: decimal point must be followed by a digit\n&quot;);
                exit(EXIT_FAILURE);
            }
        } else if (c &lt; '0' || c &gt; '9') {
            printf(&quot;Error: non-digit character in number\n&quot;);
            exit(EXIT_FAILURE);
        }
    }

    double value = strtod(str, &amp;endptr);

    if (errno != 0) {
        /* Some error occurred */
        printf(&quot;Failed to parse double: %d\n&quot;, errno);
        exit(EXIT_FAILURE);
    }

    /* If we got here, strtod() successfully parsed a number */
    return value;
}

/*
    Function: perform_operation_on_meters

    This function does a math operation on two 'meter' values. 
    It uses raw values from 'meter' objects, does the math, 
    and then wraps the result in a new 'meter' object.

    Here are the steps:

    1. Get raw double values from input 'meter' objects.
       These values are already checked to be good.

    2. Perform the operation (add, sub, mul, div) on the raw values.
       The result is a double.

    3. Wrap the result in a new 'meter' object.
       This also checks that the result is a valid 'meter' value.

    If the math result is not valid for 'meter' (e.g., negative or too big), 
    the new 'meter' object will hold an error message.

    Although the function works with 'meter' and 'operation' objects, 
    the actual math is done on raw double values. 
    This makes the function easier to write and understand.

    Parameters:
    m1 - The first 'meter' object.
    m2 - The second 'meter' object.
    op - The operation to perform.

    Returns:
    A new 'meter' object holding the result of the operation.
*/
meters* perform_operation_on_meters(meters* m1, meters* m2, operation* op) {
    // Extract the nested values
    double operand1 = m1-&gt;value;
    double operand2 = m2-&gt;value;

    switch (op-&gt;value) {
        case OPERATION_ADD:
            printf(&quot;performing add operation:\n&quot;);
            double add_result = operand1 + operand2;
            return meters_new(add_result);
        case OPERATION_SUB:
            printf(&quot;performing sub operation:\n&quot;);
            double sub_result = operand1 - operand2;
            return meters_new(sub_result);
        case OPERATION_MUL:
            printf(&quot;performing mul operation:\n&quot;);
            double mul_result = operand1 * operand2;
            return meters_new(mul_result);
        case OPERATION_DIV:
            printf(&quot;performing div operation:\n&quot;);
            double div_result = operand1 / operand2;
            return meters_new(div_result);
        default:
            printf(&quot;Error: operation value is invalid\n&quot;);
            exit(EXIT_FAILURE);
    }
}


/*
    The main function that takes command-line arguments and performs a specified operation on two meter values.

    Usage examples:
    &gt; myprogram 2 add 3
    This will add 2 and 3

    &gt; myprogram 5.5 mul 6
    This will multiply 5.5 and 6

    &gt; myprogram 10 div 2
    This will divide 10 by 2

    Arguments:
    argv[1] - the first operand, a floating point number as a string
    argv[2] - the operation, a string that is one of the following: add, sub, mul, div
    argv[3] - the second operand, a floating point number as a string

    Parameter Limits:
    The operands (argv[1] and argv[3]) should be positive numbers less than 1000. 
    The operation (argv[2]) should be one of the following: add, sub, mul, div.
*/
int main(int argc, char* argv[]) {

    if (argc != 4) {
        printf(&quot;Usage: %s &lt;operand1&gt; &lt;operation&gt; &lt;operand2&gt;\n&quot;, argv[0]);
        exit(EXIT_FAILURE);
    }

    int has_init_errors = 0;

    meters* m1 = meters_new(parse_double(argv[1]));
    if (m1-&gt;err != NULL) {
        printf(&quot;Error in first meter value: %s\n&quot;, m1-&gt;err-&gt;message);
        has_init_errors = 1;
    }

    operation* op = operation_from_string(argv[2]);
    if (op-&gt;err != NULL) {
        printf(&quot;Error in operation: %s\n&quot;, op-&gt;err-&gt;message);
        has_init_errors = 1;
    }

    meters* m2 = meters_new(parse_double(argv[3]));
    if (m2-&gt;err != NULL) {
        printf(&quot;Error in second meter value: %s\n&quot;, m2-&gt;err-&gt;message);
        has_init_errors = 1;
    }

    if (has_init_errors) {
        meters_free(m1);
        meters_free(m2);
        operation_free(op);
        exit(EXIT_FAILURE);
    }

    // Perform operation and print result
    printf(&quot; - Operand 1: %f\n&quot;, m1-&gt;value);
    printf(&quot; - Operand 2: %f\n&quot;, m2-&gt;value);
    meters* result = perform_operation_on_meters(m1, m2, op);
    if (result-&gt;err != NULL) {
        printf(&quot;Error in result: %s\n&quot;, result-&gt;err-&gt;message);
    } else {
        printf(&quot; - Result: %f\n&quot;, result-&gt;value);
    }

    meters_free(m1);
    meters_free(m2);
    meters_free(result);

    operation_free(op);
    return 0;
}
</code></pre>
<p><strong>error.h:</strong></p>
<pre><code class="lang-c">#ifndef ERROR_H
#define ERROR_H

typedef struct error {
    int code;
    char* message;
} error;

#endif // ERROR_H
</code></pre>
<p><strong>meters.h:</strong></p>
<pre><code class="lang-c">#ifndef METERS_H
#define METERS_H
#include &quot;error.h&quot;

typedef struct meters {
    double value;
    error* err;
} meters;

meters* meters_new(double value);
void meters_free(meters* m);

#endif // METERS_H
</code></pre>
<p><strong>operation.h:</strong></p>
<pre><code class="lang-c">#ifndef OPERATION_H
#define OPERATION_H
#include &quot;error.h&quot;

typedef enum {
    OPERATION_NONE,
    OPERATION_ADD,
    OPERATION_SUB,
    OPERATION_MUL,
    OPERATION_DIV,
    OPERATION_UNKNOWN,
} operation_type;

typedef struct operation {
    operation_type value;
    error* err;
} operation;


operation* operation_from_string(char* op_str);

operation* operation_new(operation_type op_type);
void operation_free(operation* op);

#endif // OPERATION_H

</code></pre>
<p><strong>meters.c:</strong></p>
<pre><code class="lang-c">#include &lt;stdlib.h&gt;
#include &quot;meters.h&quot;

// Function that creates a new meter struct, with error checking.
meters* meters_new(double value) {
    meters* new_meter = (meters*)malloc(sizeof(meters));
    if (value &lt; 0) {
        error* err = (error*)malloc(sizeof(error));
        err-&gt;code = 1;
        err-&gt;message = &quot;Error: Meter value must be non-negative&quot;;
        new_meter-&gt;err = err;
    }  else if (value &gt; 999) {
        error* err = (error*)malloc(sizeof(error));
        err-&gt;code = 2;
        err-&gt;message = &quot;Error: Meter value must be less than 1000&quot;;
        new_meter-&gt;err = err;
    }
    else {
        new_meter-&gt;value = value;
        new_meter-&gt;err = NULL;
    }
    return new_meter;
}

// Function to free the memory allocated for a meter struct.
void meters_free(meters* m) {
    if (m-&gt;err != NULL) {
        free(m-&gt;err);
    }
    free(m);
}
</code></pre>
<p><strong>operation.c:</strong></p>
<pre><code class="lang-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &quot;operation.h&quot;

// Function to create an operation from a string, with error checking.
// Please notice the separation of concerns. In this function, 
// we first deal with the problem of parsing the string from the user input into the numeric value. 
// Then, we create a value objects, which validates the operation number is valid.
operation* operation_from_string(char* op_str) {
    const size_t add_token_len = 3;
    const size_t sub_token_len = 3;
    const size_t mul_token_len = 3;
    const size_t div_token_len = 3;

    if (strnlen(op_str, 10) == add_token_len &amp;&amp; strncmp(op_str, &quot;add&quot;, add_token_len) == 0) {
        return operation_new(OPERATION_ADD);
    } else if (strnlen(op_str, 10) == sub_token_len &amp;&amp; strncmp(op_str, &quot;sub&quot;, sub_token_len) == 0) {
        return operation_new(OPERATION_SUB);
    } else if (strnlen(op_str, 10) == mul_token_len &amp;&amp; strncmp(op_str, &quot;mul&quot;, mul_token_len) == 0) {
        return operation_new(OPERATION_MUL);
    } else if (strnlen(op_str, 10) == div_token_len &amp;&amp; strncmp(op_str, &quot;div&quot;, div_token_len) == 0) {
        return operation_new(OPERATION_DIV);
    } else {
        error* err = (error*)malloc(sizeof(error));
        err-&gt;code = 1;
        err-&gt;message = &quot;Error: operation string is invalid&quot;;
        operation* new_op = (operation*)malloc(sizeof(operation));
        new_op-&gt;err = err;
        return new_op;
    }
}

// Function to create a new operation value object, with error checking.
operation* operation_new(operation_type op_type) {
    operation* new_op = (operation*)malloc(sizeof(operation));

    if (op_type &lt;= OPERATION_NONE || op_type &gt;= OPERATION_UNKNOWN) {
        error* err = (error*)malloc(sizeof(error));
        err-&gt;code = 2;
        err-&gt;message = &quot;Error: operation value is invalid&quot;;
        new_op-&gt;err = err;
    } else {
        new_op-&gt;value = op_type;
        new_op-&gt;err = NULL;
    }

    return new_op;
}

// Function to free the memory allocated for an operation struct.
void operation_free(operation* op) {
    if (op-&gt;err != NULL) {
        free(op-&gt;err);
    }
    free(op);
}
</code></pre>
<p><a href="2023-06-01-the-value-objects.assets/code-snippets/2023-06-11-the-c-lang-value-object/readme.html">readme.md</a></p>
<div class="NOTE">
<h5>Note</h5>
<p>I don't know to where this article will go, but
<em>To be continued...</em>
End of Revision 2023-06-01</p>
</div>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dzharii/personal-blog-dmytro.zharii.com/blob/main/articles/2023-06-01-the-value-objects.md/#L1" class="edit-link">Edit this page</a>
        </div>
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>